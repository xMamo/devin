\chapter{Haskell}\label{ch:haskell}

\lstset{language=haskell, frame=lines, aboveskip=\bigskipamount, belowskip=\bigskipamount}

% \hole{haskell.tex 2007/09/21}

\newcommand{\lazy}{\emph{lazy}\,}
\lstnewenvironment{haskellCode} 
{\lstset{language=haskell, tabsize=3, showspaces=false, frame=lines, aboveskip=\bigskipamount, belowskip=\bigskipamount}} {} 

In questo capitolo verranno inizialmente analizzati i vantaggi e gli svantaggi dei linguaggi funzionali per poi procedere nella descrizione del linguaggio funzionale Haskell e le sue principali caratteristiche. 

\section{Linguaggi funzionali}
I linguaggi di programmazione possono essere classificati in quattro distinte categorie: 
linguaggi imperativi, linguaggi funzionali, linguaggi logici e linguaggi logico-funzionali.
I linguaggi di programmazione sono classificati come funzionali quando le loro 
operazioni di base sono definite utilizzando le funzioni ed 
inoltre ereditano caratteristiche peculiari ad esse, come ad esempio quella di trattare 
le funzioni come dati qualunque, ammettendo dunque funzioni \emph{di ordine superiore} (higher-order). Le funzioni di ordine superiore possono: accettare come parametri attuali 
altre funzioni, restituire funzioni come risultati o immagazzinarle in strutture dati. Inoltre possono  anche venir composte tra 
loro per dare origine a nuove funzioni.

Il seguente esempio illustra come vengono scritti in Haskell tre funzioni che definiscono, rispettivamente, il 
fattoriale di $n$, la somma dei primi $n$ interi, e la somma dei quadrati 
dei primi $n$ interi:
\begin{haskellCode}
fact n  | n == 0  = 1
	| n > 0   = n * fact(n-1)

sumInt n | n == 0  = 0
	 | n > 0   = n + sumInt(n-1)

sumSqr n | n == 0  = 0
	 | n > 0   = n * n + sumSqr(n-1)
\end{haskellCode}
Guardando attentamente queste funzioni si pu\`o vedere come si basino tutte sullo 
stesso principio di ricorsione: una volta definito il caso base, il valore 
della funzione su $n$ \`e dato in termini del suo valore per $n-1$. Volendo astrarre il principio di ricorsione in termini di caso 
base e di funzione che combina i valori successivi, si riscriverebbe:
\begin{haskellCode}
ind b c n | n == 0  = b
	  | n > 0   = c n (ind b c (n-1))
\end{haskellCode}
La prima equazione indica che si ottiene il valore di base qualora $n$ sia uguale a zero, 
e la seconda equazione afferma che la combinazione di valori si 
ottiene usando una funzione con due parametri, il primo coincide col 
valore attuale di $n$, mentre il secondo \`e il valore restituito 
dall'induzione su $n-1$. Nel seguito si indicher\`a l'applicazione di
funzione semplicemente con l'accostamento dei due simboli della stessa.

Con questa notazione si pu\`o ricondurre ai precedenti esempi: 
\texttt{fact} usa la moltiplicazione per combinare i valori con il caso base impostato sul valore uno
 mentre \texttt{sumInt} usa il valore zero come caso base, e l'addizione 
per combinare. In Haskell, \texttt{(*)} denota la funzione di 
moltiplicazione, mentre \texttt{(+)} quella di addizione; Si pu\`{o} allora 
definire le funzioni  usando \verb"ind" definita in precedenza:
\begin{haskellCode}
fact   n = ind 1 (*) n
sumInt n = ind 0 (+) n
\end{haskellCode}
La funzione \verb"sumSqr" necessit\`a di un'ulteriore funzione per 
eseguire la somma dei quadrati del primo argomento e del secondo; La mancanza di una funzione predefinita
per eseguire questo calcolo rende necessaria la definizione di una nuova funzione che lo esegua.
\begin{haskellCode}
f x y = x * x + y
\end{haskellCode}
ora la funzione \verb"sumSqr" pu\`{o} essere definita come segue:
\begin{haskellCode}
sumSqr n = ind 0 f n
\end{haskellCode}
Poich\'{e} la funzione \verb"f" sar\`a necessaria solo 
in questa definizione pu\`{o}  essere utilizzata una differente notazione di funzione. Questa nuova notazione richiama quella
usata nel lambda calcolo $(\lambda x y.x \cdot x+y)$ che, 
scritta in Haskell, diventa \lstinline{(\x y -> x * x + y)}. Adesso si pu\`o definire \verb"sumSqr" 
come:
\begin{haskellCode}
sumSqr n = ind 0 (\x y -> x * x + y) 
\end{haskellCode}
Un'ulteriore metodologia per utilizzare la funzione \verb"f", in modo che essa non sia visibile all'esterno, e perci\`{o} utilizzabile da altre 
funzioni, \`{e} l'utilizzo del costrutto \lstinline{where}, che permette di creare definizioni locali all'equazione a cui si riferisce. Quindi la nuova definizione di \verb"sumSqr" risulta essere
\begin{haskellCode}
sumSqr n = ind 0 f n
  where
    f x y = x * x + y
\end{haskellCode}
Questo semplice esempio ha illustrato la potenza espressiva di un 
linguaggio funzionale fondato unicamente sulla definizione e sulla 
applicazione di funzioni.

\subsection{Vantaggi e svantaggi dei linguaggi 
funzionali}
I principali vantaggi dei linguaggi funzionali si possono riassumere come segue:
\begin{description}
    \item[La dichiarativit\`a delle espressioni che hanno valori 
    unici.] L'ordine di esecuzione non \`e specificato dal programmatore ma 
    viene demandato al sistema, che si occuper\`a di calcolare i valori a 
    partire dalle relazioni esistenti tra i dati. I linguaggi funzionali 
    possono essere visti come una ``matematica eseguibile''; La notazione \`e
    stata studiata per essere pi\`u simile allo stile di scrittura 
    matematico. Inoltre data l'assenza dello stato le espressioni devono avere sempre lo stesso valore;

    \item[La trasparenza referenziale.] Ci consente di sostituire alle 
    variabili i loro valori e vice versa, dato che le espressioni possono 
    essere calcolate in qualsiasi contesto nello stesso modo. Questa propriet\`a, tipica delle 
    espressioni matematiche, permette la manipolazione o la trasformazione di 
    un programma seguendo un ragionamento di tipo equazionale (sostituendo un'uguaglianza 
    dopo l'altra). Per questo motivo si afferma che i programmi funzionali 
    sono matematicamente pi\`u trattabili delle loro controparti imperative;

    \item[Le funzioni d'ordine superiore] che possono prendere funzioni come parametri, e restituirne altre come risultato;

    \item[Il polimorfismo.] Questa caratteristica permette di scrivere un singolo algoritmo 
    in grado di funzionare su input di pi\`u tipi, a patto che l'algoritmo non 
    dipenda da propriet\`a intrinseche del tipo di input stesso.

\end{description}
Sfortunatamente, l'adozione di questi linguaggi presenta anche qualche 
svantaggio:
\begin{description}
    \item[La perdita di prestazioni.] Dato che non \`e permesso 
    mantenere o aggiornare variabili di stato; se da un lato questa \`e la 
    buona conservazione di una propriet\`a matematica, dall'altro \`e una 
    limitazione che si rivela problematica soprattutto nel trattamento di 
    grosse strutture dati, che devono venir duplicate per intero, anche se 
    sono aggiornate solo con cambiamenti minimi. Anche gli stati sono 
    importanti per modellare l'I/O in modo naturale. I linguaggi funzionali di 
    pi\`u recente introduzione, come Haskell, riescono ad aggirare 
    quest'ultimo problema, pur soffrendo ancora sul piano dell'efficienza, mediante l'uso delle \emph{monad}.

    \item[La minor diffusione.] Questi linguaggi sono impiegati per lo pi\`u in realt\`a sperimentali e di 
    ricerca. Ci sono quindi molti meno sforzi per fornire strumenti ed ambienti di 
    programmazione in quest'ambito.
\end{description}

\section{La programmazione funzionale in Haskell}

In Haskell un programma \`e un insieme di funzioni. Ad esempio, le 
seguenti funzioni definiscono, rispettivamente, l'area del cerchio di 
raggio $r$ e l'approssimazione di Stirling per il fattoriale del numero 
n, dato da $(\frac{n}{e})^{n}\cdot\sqrt{2\pi n}$:
\begin{haskellCode}
area r     = pi * r * r
e          = 2.717281828
stirling n = (n/e)**n * sqrt(2*pi*n)
\end{haskellCode}



Una funzione pu\`o richiedere l'impiego di una clausola \verb"where" per 
definire valori o altre funzioni, impiegati solo all'interno di una 
espressione. L'esempio che segue definisce la funzione del cubo di un 
numero all'interno di una formula per calcolare il volume di una sfera di 
raggio $r$, che risulta essere uguale a $\frac{4}{3}\pi r^{3}$:
\begin{haskellCode}
volume r    =  4.0 / 3.0 * pi * (cube r)
	where
		cube x  =  x * x * x
\end{haskellCode}
Pu\`o essere impiegato anche il costrutto \verb"let", che \`e equivalente 
al \verb"where" nel caso di una espressione singola, come nella seguente 
ridefinizione dell'esempio sopra.
\begin{haskellCode}
volume' r  = let
	cube x  =  x * x * x
		in 4.0 / 3.0 * pi * (cube r)
\end{haskellCode}

\subsubsection{Definizione di funzioni}
Talvolta le funzioni possono essere definite per casi, a seconda del 
valore di un dato argomento. Haskell offre pi\`u di una tecnica per 
definire una funzione per casi.
Innanzitutto, il costrutto \emph{if\_then\_else} pu\`o essere impiegato 
dentro una funzione:
\begin{haskellCode}
fact n = if (n == 0)
    then 1
    else n * fact (n - 1)
\end{haskellCode}

Un'altra tecnica \`e quella di utilizzare le \emph{guardie}\index{guardie}:
\begin{haskellCode}
fact n | n == 0    = 1
       | otherwise = n * fact (n - 1)
\end{haskellCode}
Il costrutto sintattico qui impiegato \`e simile al modo in cui le 
funzioni sono definite per casi \emph{matematicamente}. Infatti una traduzione del secondo esempio utilizzando una notazione matematica
 \`{e} la seguente:
\begin{haskellCode}
fact(n) = \begin{cases}
          1& \text{if $n = 0$}, \\
          n * fact(n - 1) & \text{otherwise}.
          \end{cases}
\end{haskellCode} 
In altri termini una 
guardia \`e una espressione booleana che, qualora valutata a \verb"True", 
provoca la selezione della corrispondente equazione. Un altro esempio di 
uso delle guardie \`e 
\begin{haskellCode}
checkVal x y | x > y    = 1
             | x < y    = -1
             | x == y   = 0
\end{haskellCode}
L'ultimo caso poteva avere come guardia la parola chiave \verb"otherwise", 
invece dell'espressione \verb"x == y".

Un terzo approccio \`e quello che impiega la tecnica del 
\emph{pattern matching}\index{pattern matching}:
\begin{haskellCode}
    fact 0 = 1
    fact n = n * fact (n - 1)
\end{haskellCode}
In questo esempio, i parametri formali nella definizione di funzione sono specificati 
come dei \emph{pattern}. Al momento di applicare la funzione ad un 
argomento, una delle equazioni della funzione viene selezionata a seconda 
di quale pattern formale realizzi un \emph{match} con il parametro attuale.
I tentativi di realizzare un match tra pattern sono eseguiti nella sequenza 
corrispondente all'ordine con cui le equazioni vengono specificate. Una 
volta trovato il primo \emph{match}, viene selezionata la 
corrispondente equazione.

\subsubsection{Operatore infisso e 
prefisso}
Sin qui \`e apparso evidente che operatori come \verb"+" o \verb"-" siano 
funzioni \emph{infisse}. Questo modo di 
scrittura ha i vantaggi di impostare le funzioni come se fossero scritte
utilizzando la notazione matematica comune. Tuttavia gli operatori possono essere scritti anche utilizzano la notazione prefissa.
 In questo caso 
l'operatore viene preceduto e seguito da parentesi. Nell'esempio che 
segue \verb"f" ed \verb"f'" definiscono la medesima funzione, ma ciascuna 
impiega gli operatori di \verb"(*)" e \verb"(+)" in modo diverso nel corpo 
della funzione:
\begin{haskellCode}
f  x y z  = x * y + z
f' x y z  = (+) ((*) x y) z
\end{haskellCode}
Alcuni operatori, quali \verb"mod" e \verb"div", vengono sempre scritti in 
forma prefissa. Ci\`o \`e dovuto al fatto che gli operatori infissi in 
Haskell possono essere scritti unicamente con ``simboli'' (come \verb"&", 
\verb"^", \verb"!", etc.), e non con caratteri alfabetici. Qualora si 
debba usare un operatore non simbolico come infisso, lo si pu\`o fare 
scrivendo il nome dell'operatore tra apici rovesciati (i.e. \verb"`mod`" e \verb"`div`").

%%
\subsection{Tipi base e costruiti}

\subsubsection{Tipi base}
Le \smartrefs{tab:funprog-tipibase,tab:funprog-operazionibase} riportano 
alcuni tipi base, unitamente ad alcune operazioni su di essi. Per 
entrambe sono dati il significato semantico ed il modo sintattico di 
esprimerli.
\begin{table}[htb]
    \begin{center}
        \begin{tabular}{|l | l | l|}
            \hline
            Tipo & Nome & Esempio \\
            \hline
            Interi (limitati) & \texttt{Int} & \texttt{42} \\
            Interi (illimitati) & \texttt{Integer} & \texttt{73765471234} \\
            Reali & \texttt{Float} & \texttt{3.1415927} \\
            Booleani & \texttt{Bool} & \texttt{False} \\
            Caratteri & \texttt{Char} & \texttt{'a'} \\
            Stringhe & \texttt{String} & \verb|"ciao"| \\
            \hline
        \end{tabular}
        \caption{I principali tipi base in Haskell}
        \label{tab:funprog-tipibase}
    \end{center}
\end{table}

\begin{table}[htb]
    \begin{center}
        \begin{tabular}{|l | l|}
            \hline
            Nome & Operazione \\
            \hline
            \texttt{a == b} & Uguaglianza ($a = b$) \\
            \texttt{a /= b} & Disuguaglianza ($a \ne b$) \\
            \texttt{a \&\& b} & AND logico ($a \land b$) \\
            \texttt{a || b} & OR logico ($a \lor b$) \\
            \texttt{truncate x} & Seleziona la parte intera \\
            \hline
        \end{tabular}
        \caption{Le principali operazioni in Haskell}
        \label{tab:funprog-operazionibase}
    \end{center}
\end{table}

\subsubsection{Tipi strutturati}
Haskell offre svariati tipi sofisticati, che sono ricavati o costruiti da 
altri tipi (i quali, a loro volta, possono essere di base o costruiti). Una descrizione sulla definizione 
dei costrutti user-defined verr\`{a} trattata pi\`u avanti con maggior dettaglio. Al momento verranno trattati i seguenti tipi:
\begin{itemize}
    \item \textbf{lista}; per esempio \verb"[Char]", che \`e una lista 
    di caratteri;
    \item \textbf{tupla}; per esempio \verb"(Int, Float)", che \`e una 
    coppia ordinata il cui primo elemento \`e un intero, ed il secondo \`e un 
    reale;
    \item \textbf{funzione}; per esempio \verb"Char -> Bool", che \`e
    una funzione che, preso un carattere come argomento, restituisce un 
    risultato booleano.
\end{itemize}

\subsubsection{Esprimere i tipi}
Il tipo di un identificatore pu\`{o} essere specificato nel corso di un 
programma. Ad esempio, se una variabile viene definita come segue:
\begin{haskellCode}
i = 68
\end{haskellCode}
allora \verb"i" sar\`a un intero, ed il suo tipo potr\`a essere indicato 
scrivendo:
\begin{haskellCode}
i :: Int
\end{haskellCode}
Allo stesso modo, una funzione avr\`a la sua specifica di tipo: 
\begin{haskellCode}
isB :: Char -> Bool
\end{haskellCode}
Quando per una funzione vengono indicati il tipo dei parametri formali ed il tipo del risultato 
si sta fornendo una \emph{signature} per tale funzione.
  Spesso la signature per una funzione viene omessa in quanto 
 il type-checker \`e quasi sempre in grado di riconoscere il tipo di 
tutti gli identificatori in un programma.

\subsubsection{Tuple}
Una tupla corrisponde al prodotto cartesiano di due o pi\`u insiemi. Per 
esempio, se i tipi del primo e del secondo elemento di una coppia fossero 
$A$ e $B$, rispettivamente, il tipo della coppia sarebbe $A \times B$. In 
Haskell verrebbe definito come \verb"(A, B)".

Le tuple possono anche venir restituite da funzioni. Questa tecnica, (detta anche \emph{tupling}), viene 
esemplificata nell'esempio seguente, dove una funzione restituisce una 
sola tupla, costituita in realt\`a dalla coppia di radici reali del 
polinomio di forma $ax^{2}+bx+c$.
\begin{haskellCode}
radici (a, b, c) = (r1, r2)
    where
    r1          =  (-b + r) / f
    r2          =  (-b - r) / f
    f           =  2 * a
    r | d >= 0  =  sqrt d
      | d <  0  =  error ``radici immaginarie''
    d           =  b * b - 4 * a * c
\end{haskellCode}

\subsection{Liste}

\subsubsection{Definire una lista}
Una lista \`e una struttura dati \emph{lineare} costituita da 
un numero variabile di dati, tutti dello stesso tipo. Possiamo cos\`i
avere:
\begin{haskellCode}
intlist = [-3, 12, -14, 56, 0, 121]
intlist :: [Int]

boollist = [True, True, False]
boollist :: [Bool]

flolist = [[25.3], [-52.75, 0.03, 3.78], [], [14.0, -283.27]]
flolist :: [[Float]]

misclist = [('a', False), ('1', True), ('d', True), ('y', False)]
misclist :: [(Char, Bool)]
\end{haskellCode}
Dove \verb"[]", che compare nel terzo esempio, \`e la lista vuota.
Alcune di esse possono essere espresse con notazione abbreviata, dove 
anzich\'e scrivere per esteso \verb"[1," \verb"2," \verb"3," \verb"4," 
\verb"5," \verb"6," \verb"7," \verb"8," \verb"9," \verb"10]", ci si limita ad usare 
usare la notazione \verb"[1..10]". Per indicare, ad esempio, la lista infinita di tutti 
i numeri pari si scrive: \verb"[2, 4 ..]".

\subsubsection{Liste intensionali}
In matematica \`e ben nota la pratica di indicare, ad esempio, l'insieme 
dei quadrati dei numeri primi scrivendo la seguente astrazione: 
$$\{x^{2}\mid x \in \mathbb{N} \land prime(x)\}$$
In particolare, un tipo ``insieme'' non \`e presente in Haskell, ma esiste 
la possibilit\`a di rappresentare insiemi utilizzando delle
liste. Cos\`i l'esempio precedente in Haskell \`e
\begin{haskellCode}
[ x * x | x <- [1..], prime x ]
\end{haskellCode}
Un altro esempio con pi\`u di un insieme generatore potrebbe essere: $$\{(x,y)|x\in 
\{1,2,3\}\land y\in \{8,9\}\}$$ che in Haskell diventa:
\begin{haskellCode}
[ (x, y) | x <- [1, 2, 3], y <- [8, 9] ]
\end{haskellCode}

\subsubsection{L'operatore (:)}
Le liste possono essere costruite anche aggiungendo elementi in testa, 
tramite l'operatore \verb"(:)", a volte detto anche \emph{cons}, o 
\emph{costruttore}. \verb"(:)", impiegato come operatore infisso, separa 
la testa dalla coda. La lista $[e_{1},e_{2},e_{3},\ldots ,e_{n}]$ \`e quindi 
solo un'abbreviazione per $(e_{1}:(e_{2}:(e_{3}\cdots (e_n:[]))))$. Per 
esempio:
\begin{haskellCode}
3 : [4, 5]                   =   [3, 4, 5]
True : []                    =   [True]
[2, 3] : [ [1], [5,6,7] ]    =   [ [2, 3], [1], [5, 6, 7] ]
\end{haskellCode}

%
\subsubsection{Funzioni su liste ed il pattern
matching} Gli operatori che possono lavorare
su liste sono molti, per una descrizione estensiva si rimanda quindi il lettore
ad una delle guide di Haskell \cite{PeytonJones03}.

Una funzione molto utile \`e quella che restituisce la dimensione di una 
lista. In Haskell possiamo definire la funzione \verb"length" come segue:
\begin{haskellCode}
length []     = 0
length (x:xs) = 1 + length xs
\end{haskellCode}
Un esempio di esecuzione della funzione \verb"length" sulla lista [1, 
54, 17] \`e presto dato:
\begin{haskellCode}
length ( 1:[54, 17] ) = 1 + length [54, 17]
                      = 1 + length ( 54:[17] )
                      = 1 + ( 1 + length [17] )
                      = 1 + ( 1 + length ( 17:[] ) )
                      = 1 + ( 1 + ( 1 + length [] ) )
                      = 1 + ( 1 + ( 1 + 0 ) )
                      = 3
    
\end{haskellCode}
Se un parametro di input non \`{e} rilevante per la computazione 
pu\`{o} essere sostituito dal carattere \emph{underscore}, anche chiamato \emph{wild-card}.
L'utilizzo della \emph{wild-card} risulta soggettivo tra gli utenti, poich\'e al suo posto potrebbe essere utilizzata
una variabile qualunque.
La definizione di \verb"length", in questo caso, diventa:
\begin{haskellCode}
length (_:xs) = 1 + length xs
\end{haskellCode}

%% pattern non-esaustivi
Un altro esempio in cui \`e presente  una forma di ricorsione molto simile 
alla precedente \`e quello della funzione \verb"last", che estrae l'ultimo 
elemento da una lista:
\begin{haskellCode}
last [x]     = x
last (_:xs) = last xs
\end{haskellCode}
L'unico problema presente in questa definizione \`e l'evenienza di avere 
come parametro attuale una lista vuota. Questo caso sarebbe non valido per 
come \`e definita la funzione e ci\`o porta a dire che la definizione 
data per \verb"last" non \`e \emph{esaustiva}. 

%
\subsubsection{Altre funzioni}
Tra le altre funzioni predefinite\footnote{La definizione di queste funzioni \`e data in
\texttt{PreludeList}, sotto-modulo dello \texttt{StandardPrelude}.} in Haskell per il
trattamento delle liste, citiamo i due operatori infissi \verb"(!!)" e \verb"(++)" che sono,
rispettivamente, l'operatore di indicizzazione di un elemento in una lista (dove il primo
elemento ha indice 0, il secondo 1 etc.  ), e la concatenazione (per concatenare due liste fra
loro).

Citiamo poi tre insiemi di funzioni, che si occupano di scomporre una 
lista:
\begin{itemize}
    \item \verb"head" e \verb"tail" restituiscono le due parti che sono 
    argomenti dell'operatore \verb"(:)"; in altri termini restituiscono 
    rispettivamente il primo elemento di una lista e la lista priva del suo 
    primo elemento;
    
    \item \verb"init" e \verb"last" spezzano la lista alla fine, e 
    restituiscono rispettivamente l'intera lista senza l'ultimo elemento, ed 
    il solo ultimo elemento;
    
    \item \verb"take n xs" e \verb"drop n xs" generalizzano il caso 
    precedente, dato che spezzano la lista, ma dopo i primi \verb"n" elementi. 
    Cos\`i \verb"take n xs" restituisce i primi \verb"n" elementi di una 
    lista, e \verb"drop n xs" la lista privata dei suoi primi \verb"n" 
    elementi.
\end{itemize}

Volendo citare degli esempi di funzioni che manifestano pattern pi\`u 
complessi nei parametri formali, si vedr\`a ora come definire una funzione per 
restituire il valore massimo degli elementi di una lista:
\begin{haskellCode}
maximum [x]                   = x
maximum (x:y:ys) | x > y      = maximum (x:ys)
	         | otherwise  = maximum (y:ys)
\end{haskellCode}
Il caso pi\`u semplice \`e il caso in cui una lista sia composta da un solo elemento  (nella 
seconda riga di definizione di \verb"maximum"). Quando la lista ha pi\`u di 
un elemento si confronta i primi due (situati all'inizio), inserendo il valore massimo tra i due in testa alla 
restante parte della lista. Si noti che la funzione 
non \`e definita per il caso di lista vuota.

Verr\`a ora analizzata, una funzione per appiattire una lista di liste in una singola. 
Gli elementi delle liste pi\`u interne vengono estratti e posti 
in una esterna, in modo da apparire nel medesimo ordine testuale. 


Si prenda ad esempio la funzione predefinita \lstinline{concat}. Verr\`{a} mostrata la 
definizione della funzione stessa e qualche eloquente esempio applicativo:
\begin{haskellCode}
concat []                   = x
concat ([]:ys)              = concat ys
concat ((x:xs):ys)          = x : concat (xs:ys)
\end{haskellCode}
\begin{haskellCode}
concat [[1,43], [-3,12,89,15], [9]] ... [1,43,-3,12,89,15,9]
concat [[], [False, False], [True]] ... [False, False, True]
concat []                           ... []
concat [[]]                         ... []
\end{haskellCode}

Una breve descrizione merita anche l'operatore \verb"@", detto anche 
'\emph{as}', che permette di etichettare tutto o una parte di un 
argomento di funzione. La sua utilit\`a nasce dall'esigenza di 
voler semplificare la stesura del codice, renderla pi\`{u} leggibile e pi\`u 
snella. Ad esempio in:
\begin{haskellCode}
rem34 (p:q:r:s:xs) | r == s     =  p:q:xs
                   | otherwise  =  p:q:r:s:xs
\end{haskellCode}
l'input viene utilizzato sia interamente che parzialmente. Impiegando 
l'operatore \verb"@", il codice precedente migliora in leggibilit\`a
\begin{haskellCode}
rem34 lab@(p:q:r:s:xs) | r == s     =  p:q:xs
                       | otherwise  =  lab
\end{haskellCode}
Cos\`i risulta ancora pi\`u evidente che nel secondo caso la funzione 
restituisce per intero il parametro dato in ingresso.

\subsubsection{Stringhe}
Una volta chiarito il concetto di lista pu\`o essere introdotto quello di stringa, 
dato che in Haskell \`e in realt\`a composta da una lista di caratteri. 
Infatti nel \emph{Prelude} del \verb"GHC"
il tipo \verb"String" e definito come segue:
\begin{haskellCode}
type String = [Char]
\end{haskellCode}
In aggiunta, la loro scrittura pu\`{o} differire dal metodo pi\`{u} convenzionale, infatti una stringa pu\`{o} essere
istanziata tramite doppi apici.
Cos\`i le quattro stringhe che seguono 
indicano tutte la medesima entit\`a.
\begin{haskellCode}
"Macintosh"
['M', 'a', 'c', 'i', 'n', 't', 'o', 's', 'h']
'M':'a':'c':'i':'n':'t':'o':'s':'h':[]
'M':'a':'c':'i':'n':"tosh"
\end{haskellCode}
La stringa nulla \verb+""+ coincide dunque con una lista vuota di tipo 
\verb"[Char]". 

Molte operazioni che vengono realizzate su stringhe non 
sono dissimili da quelle su liste come, ad esempio, determinare la lunghezza di una 
stringa o concatenare due stringhe tra loro. C'\`e una funzione 
\verb"show", che converte qualsiasi argomento\footnote{Appartenente alla classe Show} in una stringa.

\subsection{Tecniche di programmazione funzionale di ordine 
superiore}
In questa sezione verr\`{a} trattato il concetto di programmazione di ordine 
superiore, che corrisponde all'idea di funzioni che ne accettano altre 
come argomento, o le restituiscono come risultato. Nella 
programmazione funzionale le funzioni di ordine superiore sono impiegate 
in maniera estensiva, dato che permettono di esprimere computazioni 
piuttosto complesse utilizzando formulazioni relativamente semplici.

\subsubsection{Mappature}
Brevemente verr\`{a} illustrata una funzione che si occupa di creare da una lista data una 
nuova i cui valori si ottengono a partire dalla prima seguendo uno 
specifico schema che \`e chiamata mappa.

Si immagini di aver bisogno di una funzione \verb"tupleList" 
che generi coppie composte dal valore zero come primo elemento e degli 
elementi di una lista data in input come secondo elemento. In altri 
termini, si vorrebbe ottenere una funzione \verb"tupleList" che, data 
\verb"['d', 'x', 'q']", restituisca \verb"[(0,'d'), (0,'x'), (0,'q')]".
Scrivere una funzione che generi una singola tupla a partire da un valore 
singolo risulta piuttosto semplice:
\begin{haskellCode}
makeTuple x = (0,x)
\end{haskellCode}
Si pu\`o ora scrivere una funzione che attua tale operazione su un'intera 
lista, come segue:
\begin{haskellCode}
tupleList []     = []
tupleList (x:xs) = (makeTuple x):(tupleList xs)
\end{haskellCode}
La tecnica \`e di passare in rassegna tutta la lista elemento per 
elemento, applicando ad ognuno la  funzione \verb"makeTuple". Si supponga 
ora di voler raddoppiare ogni elemento della lista. Seguendo quanto appena 
fatto, scriveremo:
\begin{haskellCode}
double x          = x + x

doupleList []     = []
doupleList (x:xs) = (double x):(doupleList xs)
\end{haskellCode}
Questo secondo esempio adotta lo stesso schema computazionale del primo, 
cambia per\`o la funzione che si applica sui dati.

Impiegando una mappatura si pu\`{o} ridefinire quanto fatto nei due esempi, 
in modo molto pi\`u semplice. Per far ci\`o si definisce una funzione di 
ordine superiore per realizzare una scansione delle liste ed applicare una 
certa funzione. Convenzionalmente questa funzione di ordine 
superiore \`{e} chiamata \verb"map", in quanto \emph{mappa} una funzione su una intera 
lista. In termini generali si definisce \verb"map" come:
\begin{haskellCode}
map f []     = []
map f (x:xs) = (f x):(map f xs)
\end{haskellCode}
Le due funzioni operanti su liste descritte prima diventano ora:
\begin{haskellCode}
tupleList   xs = map makeTuple xs
doupleList  xs = map double xs
\end{haskellCode}

\subsubsection{Funzioni anonime}
Nell'ambito della programmazione si ha spesso la necessit\`{a} di utilizzare delle funzioni all'interno di altre, senza 
per questo volerle definire globalmente e localmente. Si vuole cio\`e definirle, impiegarne 
l'output e dimenticare la loro definizione. Per endere possibile questo tipo di operazioni Haskell fa uso delle 
\emph{funzioni anonime}. Ad 
esempio la funzione anonima che corrisponde alla precedente 
\verb"makeTuple" verrebbe scritta come:
\begin{haskellCode}
\x -> (0, x)
\end{haskellCode}
La notazione impiegata \`e molto simile a quella 
adottata dal $\lambda$-calcolo dove, in 
termini matematici, si sarebbe scritto $(\lambda x.(0,x))$. Riferendosi sempre all'esempio precedente, 
questa funzione anonima viene direttamente inserita 
nella definizione di \verb"tupleList" e di \verb"doupleList" nel modo seguente:
\begin{haskellCode}
tupleList  xs = map (\x -> (0, x)) xs
doupleList xs = map (\x -> x + x) xs
\end{haskellCode}


\subsubsection{Folding}
Un altro modello di computazione molto utilizzato in Haskell \`e
il cosiddetto \emph{folding}. L'operazione di folding calcola un 
singolo valore a partire da una lista. Vengono ora riportati due esempi di definizioni di 
funzione tipo su cui applicare in un secondo momento la tecnica del 
folding.
%
\begin{haskellCode}
somma []      =  0
somma (x:xs)  =  x + sum xs
\end{haskellCode}

\begin{haskellCode}
prodotto []     = 1
prodotto (x:xs) = x * prodotto xs
\end{haskellCode}

A differenza di quanto visto prima per le mappe, queste due funzioni operano su due 
strutture sintattiche che differiscono non solo per il tipo di funzione 
applicata, ma anche per il comportamento adottato nel caso base.
Generalizzando il caso base con $b$ e l'operazione di funzione con 
$\oplus$, si pu\`o riscrivere un'astrazione delle funzioni precedenti su 
un parametro di lista di $n$ elementi, ottenendo: $$(e_{0} \oplus (e_{1} 
\oplus (e_{2} \oplus \cdots (e_{n} \oplus b) )))$$
Appare chiaro che le funzioni precedenti operano il folding di valori a 
partire dall'elemento pi\`u a destra della lista. In casi come questo 
Haskell offre al programmatore l'utilizzo della funzione \verb"foldr", per 
ottenere definizioni di questo tipo:
\begin{haskellCode}
somma xs    = foldr (+) 0 xs
prodotto xs = foldr (*) 1 xs
\end{haskellCode}
%
La funzione \verb"foldr" \`e definita in Haskell come:
\begin{haskellCode}
foldr _ b []     = b
foldr f b (x:xs) = f x (foldr f b xs)
\end{haskellCode}
%
Si noti che \`e stato necessario racchiudere tra parentesi gli operatori 
di somma e prodotto (\verb"(+)" e \verb"(*)"), dato che le fuzioni vengono passate 
come parametri. Questa operazione di inclusione tra parantesi si dovrebbe fare anche nel caso in cui il parametro sia la 
concatenazione o il costruttore di liste. Un 
esempio \`e visibile nella seguente ridefinizione di due funzioni gi\`a presentate:
\begin{haskellCode}
xs ++ ys  = foldr (:) ys xs
concat xs = foldr (++) [] xs
\end{haskellCode}
%
D'altra parte si vorrebbe impiegare un'operazione di folding con una 
funzione che lavora costruendo il suo risultato a partire dall'elemento 
pi\`u a sinistra. Riprendendo la sintassi sopra definita:
$$((((b \oplus e_{n}) \oplus e_{n-1}) \oplus e_{n-2}) \oplus \cdots 
e_{0})$$
Nel caso in cui si presentino funzioni astratte come quella sopra riportata, si dovrebbe usare 
\verb"foldl" (speculare di \verb"foldr"). Tale funzione \`e definita in Haskell come:
\begin{haskellCode}
foldl _ b []     = b
foldl f b (x:xs) = foldl f (f b x) xs
\end{haskellCode}
%
Nel caso in cui si stia trattando funzioni che utilizzano la tecnica del 
folding, ma non necessitino di essere definite per il caso base, si 
impiegano \verb"foldr1" e \verb"foldl1" (che operano solo su liste non 
vuote) che sono definite come segue:
\begin{haskellCode}
foldr1 _ [x]    = x
foldr1 f (x:xs) = f x (foldr1 f xs)
\end{haskellCode}
\begin{haskellCode}
foldl1 _ [x]    = x
foldl1 f (x:xs) = foldl f x xs
\end{haskellCode}

Un'ulteriore esempio che mette in evidenza l'espressivit\`{a} di un linguaggio funzionale come Haskell \`{e}
dato dalla ridefinizione della funzione \verb"map":
\begin{haskellCode}
map f = foldr ((:).f) []
\end{haskellCode}
In questo caso viene utilizzata la funzione \verb"foldr" che applica la funzione, 
passata come parametro attuale, a tutti gli elementi della lista. Un'ulteriore caratteristica da notare \`{e}
la composizione di due funzioni, che in questo caso sono \verb"(:)" e \verb"f". 
Come in matematica, la composizione di funzioni applica ad un elemento 
la funzione pi\`u esterna e calcola il risultato che viene passato come input alla seconda funzione. 

\subsection{Tipi algebrici e polimorfismo}
Nella precedente sezione \`e stata discussa la struttura di una lista 
in termini dell'applicazione del costruttore \verb"(:)". Questa sezione 
descrive i costruttori in generale, ed il modo in cui i loro tipi possono 
essere espressi. Si accenna anche al polimorfismo semplice, o parametrico, inteso come ci\`o che 
permette ad una stessa funzione di operare su tipi diversi. Infine, in contrapposizione al polimorfismo parametrico, 
si analizza il polimorfismo \emph{ad-hoc}, comunemente chiamato \emph{overloading}.

\subsubsection{Tipi definiti 
dall'utente}
Haskell permette di definire tipi mediante i costruttori. Un 
costruttore opera esattamente come una funzione, dato che riceve degli 
argomenti in input e restituisce un valore del tipo che definisce.

Si supponga, ad esempio, di voler definire un nuovo tipo di dato, che verr\`a chiamato 
\verb"CoordType", per codificare i valori delle coordinate di un piano 
cartesiano. Per fare ci\`o si definisce prima un costruttore di tipo, denominato \verb"Coord",
 con due argomenti, le componenti $x$ ed $y$, che 
restituiscono i valori di \verb"CoordType". 
\begin{haskellCode}
data CoordType = Coord Float Float
\end{haskellCode}

Una volta definito un nuovo tipo si possono scrivere funzioni generiche che 
lavorano sui valori di questo tipo usando il pattern matching come, ad 
esempio, le due funzioni che restituiscono la componente $x$ ed $y$ di una 
coordinata:
\begin{haskellCode}
componenteX (Coord x _) = x
componenteY (Coord _ y) = y
\end{haskellCode}
%
Si noti la forma di pattern matching qui adottata che, sebbene simile a quella 
del caso delle liste, si differenzia perch\'e il costruttore di 
funzione \`e prefisso, mentre nell'altro caso era infisso. 

La seguente funzione prende come argomento una lista di coordinate e 
controlla se sono tutte nel primo quadrante cartesiano (entrambe le componenti sono positive):
\begin{haskellCode}
primoQuadr []               = True
primoQuadr ((Coord x y):cs) = (x >= 0) && 
                              (y >= 0) && 
                              (primoQuadr cs)
\end{haskellCode}

\subsubsection{Costruttori 
alternativi}
In alcune situazioni i valori di un tipo di dato non vengono creati da un 
solo costruttore. S'immagini il caso di un tipo di dato che conservi la ``forma'' 
(che pu\`o essere un rettangolo, un triangolo o un 
cerchio) con informazioni sulle sue componenti diverse in base alla  
``forma'' stessa. Un rettangolo avr\`a cos\`i le due sole coordinate degli angoli, un triangolo le tre dei vertici ed il 
cerchio la 
coordinata del centro e la lunghezza del raggio. Si pu\`o definire questo 
tipo di dato indicando le alternative separate dalla barra verticale 
\verb"(|)":
\begin{haskellCode}
data Forma = Rettangolo CoordType CoordType
    | Cerchio CoordType Float
    | Triangolo CoordType CoordType CoordType
\end{haskellCode}
%
Un tipo \verb"Forma" \`e dunque un \verb"Rettangolo", un \verb"Cerchio", 
oppure un \verb"Triangolo". Seguono tre esempi di valori di tipo 
\verb"Forma":
\begin{haskellCode}
Rettangolo (Coord 13.0 27.3) (Coord 4.9 12.1)
Cerchio (Coord 64.0 37.0) 7.5
Triangolo (Coord 0.0 0.0) (Coord 45.3 6.0) (Coord 12.8 17.0)
\end{haskellCode}
%
Una funzione che accetti un argomento rappresentato da un tipo di dato e che abbia costruttori 
alternativi deve avere almeno un pattern che corrisponde ad ognuno dei 
costruttori. Una funzione \verb"area" che calcola l'area di un poligono di 
tipo \verb"Forma" sar\`a:
\begin{haskellCode}
area (Rettangolo angolo1 angolo2)
    = abs(componenteX angolo1 - componenteX angolo2) *
      abs(componenteY angolo1 - componenteY angolo2)
      
area (Cerchio _ raggio) = pi * raggio * raggio

area (Triangolo vertice1 vertice2 vertice3)
    = sqrt (h * (h-a) * (h-b) * (h-c))
  where
    h = (a + b + c ) / 2.0
    a = dist vertice1 vertice2
    b = dist vertice1 vertice3
    c = dist vertice2 vertice3
    dist (Coord x1 y1) (Coord x2 y2)
    	= sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
\end{haskellCode}
%
Se \verb"area" fosse stata definita utilizzando le sole prime due funzioni, il pattern 
specificato nella definizione della funzione \verb"area" non sarebbe stato 
esaustivo. In tal caso se fosse stato passato un parametro costituto da un 
dato creato con il costruttore \verb"Triangolo", l'algoritmo di \emph{pattern-matching}
avrebbe fallito.

\subsubsection{Polimorfismo 
semplice}

Si supponga ora di voler determinare il tipo della funzione \verb"fst", 
definita come:
\begin{haskellCode}
fst (x, _) = x
\end{haskellCode}
%
Il tipo di questa funzione dipende dal contesto in cui la chiamata viene 
effettuata. In \smartref{tab:funprog-polimorfismosemplice} sono riportati 
alcuni tipi possibili che \verb"fst" pu\`o assumere. Sembrerebbe 
cos\`i possibile associare ad \verb"fst" un determinato tipo solo 
quando si applica ad un valore. Questo non \`e molto 
soddisfacente perch\'e si vorrebbe dare un tipo generale a qualsiasi 
funzione, indipendentemente da dove viene usata.
\begin{table}[htb]
    \begin{center}
        \begin{tabular}{|l l|}
            \hline
            Contesto & Tipo di \verb"fst"\\
            \hline
            \verb"w = fst(32, 8)" & \verb"fst :: (Int, Int) -> Int" \\
            \verb"x = fst('c', True)" & \verb"fst :: (Char, Bool) -> Char" \\
            \verb"y = fst([3,5,6], 145.9)" & \verb"fst :: ([Int], Float) -> [Int]" \\
            \verb+z = fst((True,"s", 0),[False])+ & 
            \verb"fst :: ((Bool,String,Int), [Bool])" \\
            & \verb"       -> (Bool,String,Int)" \\
            \hline
        \end{tabular}
        \caption{Alcuni tipi possibili per \texttt{fst"}}
	\label{tab:funprog-polimorfismosemplice}
    \end{center}
\end{table}
%
Per soddisfare questa richiesta, in Haskell, il tipo di \verb"fst" viene definito come segue:
\begin{haskellCode}
fst :: (a, b) -> a
\end{haskellCode}
%
dove \verb"a" e \verb"b" sono \emph{variabili di tipo} che possono essere 
istanziate con tipi concreti (come \verb"Int", \verb"Float", \verb"Bool", 
\verb"[Char]", e cos\`i via) non appena la funzione viene invocata. 
Tale definizione di tipo si limita ad indicare che \verb"fst" accetta un 
argomento che \`e una coppia. In realt\`a definisce anche che il tipo del 
risultato che deve coincidere con quello del primo elemento della coppia (dato che 
usa la stessa variabile, \verb"a"). Si chiama \emph{polimorfa} una 
funzione la cui definizione di tipo contiene variabili di tipo. La pi\`u 
semplice funzione polimorfa \`e la funzione identit\`a
\begin{haskellCode}
id x = x
\end{haskellCode}
Questa funzione restituisce il suo argomento, che pu\`o essere di \emph{qualsiasi} tipo. 
Il tipo di \verb"id" \`e infatti:
\begin{haskellCode}
id :: a -> a
\end{haskellCode}

\subsubsection{Polimorfismo di lista}
Si consideri ora il tipo di dato \emph{lista}. Se non fosse gi\`a incluso 
nell'implementazione di Haskell, si potrebbe definire come un tipo di 
dato, specificando le propriet\`a che ci si aspetta da una lista. Ad 
esempio, il seguente tipo di dato (ricorsivo) rappresenta una lista di 
interi:
\begin{haskellCode}
data IntList = Nil
    | Cons Int IntList
\end{haskellCode}
Una lista come \verb"[14," \verb"9," \verb"12]" si potrebbe cos\`i rappresentare simbolicamente con l'espressione
\begin{haskellCode}
Cons 14 (Cons 9 (Cons 12 Nil))
\end{haskellCode}
Mentre una funzione che determina la dimensione di una tale lista sar\`a
\begin{haskellCode}
lengthList Nil = 0
lengthList (Cons _ xs) = 1 + lengthList xs
\end{haskellCode}
Ad ogni modo la lista appena definita \`e limitata agli interi. La 
propriet\`a di \emph{comportarsi come una lista} non ha nulla a che vedere 
con il tipo di elementi nella stessa (sebbene i dati siano tutti dello 
stesso tipo).

Utilizzando una \emph{definizione di dati polimorfa}, si pu\`o 
rappresentare una struttura dati liberamente, senza includere alcun vincolo. 
Consideriamo la seguente definizione di una struttura dati che si 
comporti come una lista:
\begin{haskellCode}
data Lista a = Cons' a (Lista a)
    | Nil'
\end{haskellCode}

Utilizzando la definizione di dati polimorfa, si posso scrivere liste di elementi, come 
ad esempio:
\begin{haskellCode}
Cons' 5 (Cons' 14 (Cons' -3 Nil'))                = [5, 14, -3]
Cons' False Nil'                                  = [False]
Cons' Nil'(Cons'(Cons' 4.7(Cons' 2.6 Nil')) Nil') = [[],[4.7, 2.6]]
\end{haskellCode}
L'ultima dichiarazione \`e un valore di tipo \verb"Lista (Lista Float)".

\subsection{Classi ed istanze}

Come accennato in precedenza, il polimorfismo semplice \`e quella caratteristica che permette ad una funzione di operare su tipi 
diversi tra loro. Ad ogni modo, non sempre risulta possibile utilizzare funzioni polimorfe per tutti i tipi di dato a causa delle grandi 
differenze strutturali che intercorrono tra di essi. In questo contesto le classi introducono un nuovo approccio che permette ad una funzione, 
tramite la definizione di un'istanza, di operare su tipi diversi tra loro. Questa caratteristica viene comunemente chiamata 
\emph{overloading} (o polimorfismo \emph{ad-hoc}) e viene utilizzata in contrapposizione al polimorfismo parametrico.

\subsubsection{Classi}
Le classi sono insiemi di funzioni. Si dice che un tipo appartiene ad una classe quando esiste un'istanza di queste funzioni sul tipo considerato. Per esempio una delle classi pi\`u utilizzate \`e la classe Eq definita nello stesso $Prelude$. 
\begin{haskellCode}
class  Eq a  where
    (==), (/=) :: a -> a -> Bool

        -- Minimal complete definition:
        --      (==) or (/=)
    x /= y     =  not (x == y)
    x == y     =  not (x /= y)
\end{haskellCode}
La classe Eq definisce due funzioni: $(==)$ e $(/=)$. Un tipo di dato in cui queste due funzioni sono state istanziate appartiene alla classe Eq.

\subsubsection{Istanze}
Dato un tipo e una classe, un'istanza \`e la definizione delle funzioni dichiarate dalla classe per il tipo considerato. Per esempio 
si potrebbe creare l'istanza della classe Eq per gli alberi.
\begin{haskellCode}
data Tree a = Void | Node a (Tree a) (Tree a)

instance  (Eq a) => Eq (Tree a) where
	Void         == Void            = True
	(Node a l r) == (Node a1 l1 r1) = (a == a1) && 
	                                  (l == l1) && 
	                                  (r == r1)
	_            == _               = False
\end{haskellCode}
Con questo codice \`e stata definita l'istanza della classe Eq per il tipo Tree. Si potrebbe, quindi, utilizzare all'interno del 
programma l'operatore di uguaglianza anche per gli alberi. Si nota per\`o che per poter utilizzare questo operatore il tipo 
utilizzato negli alberi deve appartenere alla classe Eq. Infatti nel definire l'operatore \emph{==} per gli alberi \`e stata utilizzata 
l'uguaglianza tra gli elementi degli alberi.\\
Un'altra cosa da notare \`e il fatto che nell'istanza \`e stata definita solamente la funzione \emph{==} mentre la classe Eq prevede 
anche la definizione della funzione \emph{/=}. Fortunatamente per definire correttamente la classe Eq \`e sufficiente dare la definizione di 
\emph{==} oppure quella di \emph{/=}. Osservando infatti la definizione del codice della classe Eq si pu\`o vedere che se viene data la 
definizione di \emph{==} si pu\`o derivare la funzione \emph{/=} tramite la negazione della funzione di uguaglianza.

Il binomio classi-istanze permette una migliore strutturazione del codice e la definizione di funzioni overloaded. Tra le classi 
pi\`u utilizzate (definite nel $Prelude.hs$) si ricorda, oltre a classe Eq, anche le classi Ord (ordinamento), Show 
(scrittura su standard output) e Read (lettura da standard input).

 
