%&PDFLaTeX

\documentclass[11pt, american, draft]{PhdThesis}

\usepackage[american]{babel}
\usepackage[final]{graphicx}

\usepackage{enumitem}
\usepackage[T1]{fontenc}
\usepackage{forest}
\usepackage[final]{listings}
\usepackage{lmodern}
\usepackage{url}

\forestset{
  default preamble = {
    for tree = {draw, ellipse}
  }
}

\lstset{
  basicstyle = \fontseries{lc}\selectfont\ttfamily,
  basewidth = 0.52em,
  upquote = true
}

\author{Matteo Morena}
\email{morena.matteo@gmail.com}
\supervisor{Marco Comini}
\title{Implementation of an interpreter with graphical interface of a simple imperative language}
\date{2021--2022}

\begin{document}
  \pagestyle{empty}
  \maketitle

  % \begin{dedication}
  %   TBD
  % \end{dedication}

  % \begin{abstract}
  %   TBD
  % \end{abstract}

  % \begin{acknowledgments}
  %   TBD
  % \end{acknowledgments}

  \frontmatter
  \partstyle{serifbig}
  \chaptertitlestyle{serifbig}
  \pagestyle{serif}
  \tableofcontents
  % \listoffigures
  % \listoftables

  % \introduction
  % TBD

  % \section*{an intro section}
  % TBD

  \mainmatter

  % \chapter{Preliminaries}
  % TBD

  % \section{a preliminaries section}
  % TBD

  \part{Conceptual overview}

  \chapter{Parsing}

  The first phase of any compiler or interpreter is called \emph{parsing}. The purpose of this
  phase is to analyze an input string and determine if it conforms to some set of rules; if it
  does, a logical representation of the input is constructed.

  Consider a parser for arithmetic expressions. The input of the parser is any sequence of
  characters. Invalid strings like \mbox{\texttt{(1 +)}} and \mbox{\texttt{(3 * * 4)}} get rejected.
  Valid strings like \mbox{\texttt{(2 * (3 + 4))}} get accepted.

  The \emph{language} accepted by a parser is the set of all possible inputs which the parser may
  accept. The set of rules to which the input has to conform to is called the \emph{grammar} of the
  language.

  As an example, we could define the grammar for arithmetic expressions as follows:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item An \emph{expression} can either be a literal expression, a binary expression, or a
          parenthesized expression;

    \item A sequence of characters representing a number is a \emph{literal expression};

    \item If $x$ and $y$ are expressions, then $x$, followed by an operator, followed by $y$, is a
          binary expression. An operator is one of the following characters: \texttt{+}, \texttt{-},
          \texttt{*}, \texttt{/}.
    
    \item If $x$ is an expression, then \texttt{(}, followed by $x$, followed by \texttt{)} is a
          \emph{parenthesized expression}.
  \end{itemize}
  
  According to such rules, the string \mbox{\texttt{(2 * (3 + 4))}} is a valid arithmetic
  expression. By definition:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \texttt{2}, \texttt{3} and \texttt{4} are literals;
    \item \mbox{\texttt{3 + 4}} is a binary expression;
    \item \mbox{\texttt{(3 + 4)}} is a parenthesized expression;
    \item \mbox{\texttt{2 * (3 + 4)}} is a binary expression;
    \item \mbox{\texttt{(2 * (3 + 4))}} is an expression.
  \end{itemize}

  \section{Grammar metalanguages}

  To express language grammars in a succinct manner, metalanguages notations are commonly used. As
  the prefix ``meta--'' suggests, we use a language to describe another language.

  A commonly used metalanguage is the Extended Backus--Naur form.

  \begin{lstlisting}
expression = parenthesizedExpression | binaryExpression | literalExpression;
literalExpression = ['+' | "-"], digit, {digit};
binaryExpression = expression, ("+" | "-" | "*" | "/"), expression;
parenthesizedExpression = "(", expression, ")";
  \end{lstlisting}

  \section{Syntax trees}

  A \emph{syntax tree} is the representation of a string accepted by the parser; this data
  structure stores the syntactic structure of the input.

  A syntax tree may retain all information necessary to reconstruct the input; in this case, it is
  called a \emph{concrete} syntax tree. If some information about the source is discarded
  (comments, for example), it is called an \emph{abstract} syntax tree.

  Consider the language of arithmetic expressions: we can think of at least two possible syntax
  trees for the string \mbox{\texttt{(2 + 3 * (4 + 5))}}, depending on how much information has been
  kept. When information is thrown away, the semantic meaning stays the same: for instance, details
  about parenthesization can be discarded if the resulting syntax tree still represents the
  same order of operations.

  \begin{figure}[h]
    \centering

    \begin{ttfamily}
      \begin{forest}[+ [2] [* [3] [+ [4] [5]]]]\end{forest}
      \begin{forest}[( ) [+ [2] [* [3] [( ) [+ [4] [5]]]]]]\end{forest}
    \end{ttfamily}

    \caption{Two semantically equivalent syntax trees for \mbox{\texttt{(2 + 3 * (4 + 5))}}}
  \end{figure}

  As we'll see later, the parser for Devin uses a single tree representation which retains enough
  information for syntax highlighting, but also discards whitespace. For our purposes, the
  distinction between abstract and concrete syntax tree isn't necessary: for this reason, from now
  on I'll just use the term \emph{syntax tree}.

  \section{Recursive descent parsing}

  There are many ways to recognize some input and generate an associated syntax tree. There has been
  much academic research, and it is trivial to find so-called \emph{parser generators}: these are
  tools which, given a grammar, automatically generate code for parsing the language in question.
  Such tools build upon well-known algorithms, such as LL, LR, LALR, just to throw a few names
  around. These tools are great and very performant; however, they're kind of magical.

  In this section, we'll see how there's no fundamental need for any generators; although such tools
  are handy, it isn't actually that difficult to write a parser from scratch, using a technique
  called \emph{recursive descent parsing}. Recursive descent parsers are used by the GCC compiler
  and the V8 JavaScript engines, for example\cite{nystrom}.

  Let's consider the language of arithmetic expressions. We can formalize the rules for valid
  arithmetic expressions as follows:

  \begin{itemize}
    \item An \emph{expression} can either be a literal expression or a binary expression;

    \item A sequence of characters representing a number is a \emph{literal expression};

    \item If $x$ and $y$ are expressions, then $x$, followed by an operator, followed by $y$, is a
          binary expression. An \emph{operator} is one of the following characters: \mbox{+},
          \mbox{-}, \mbox{*}, \mbox{/}.
  \end{itemize}

  \backmatter

  % \conclusions
  % TBD

  % \appendix

  % \chapter{Some technicalities}
  % TBD

  % \section{a section}
  % TBD

  \backmatter

  \bibliographystyle{plain}
  \bibliography{biblio}

  % \printindex  % use makeindex to generate the index
\end{document}
