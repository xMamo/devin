\documentclass[11pt, american, draft]{PhdThesis}

\usepackage[american]{babel}
\usepackage[final]{graphicx}

\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{forest}
\usepackage{float}
\usepackage{fontawesome}

\usepackage{biblatex}
\addbibresource{biblio.bib}

\forestset{
  default preamble = {
    for tree = {draw, ellipse}
  }
}

\raggedbottom

\author{Matteo Morena}
\email{morena.matteo@gmail.com}
\supervisor{Marco Comini}
\title{Implementation of an interpreter with graphical interface of a simple imperative language}
\date{2021--2022}

\begin{document}
  \pagestyle{empty}
  \maketitle

  % \begin{dedication}
  %   TBD
  % \end{dedication}

  % \begin{abstract}
  %   TBD
  % \end{abstract}

  % \begin{acknowledgments}
  %   TBD
  % \end{acknowledgments}

  \frontmatter
  \partstyle{serifbig}
  \chaptertitlestyle{serifbig}
  \pagestyle{serif}
  \tableofcontents
  % \listoffigures
  % \listoftables

  % \introduction
  % TBD

  % \section*{an intro section}
  % TBD

  \mainmatter

  % \chapter{Preliminaries}
  % TBD

  % \section{a preliminaries section}
  % TBD

  \chapter{Parsing}

  The first phase of any compiler or interpreter is called \emph{parsing}. Given an input string, it
  is determined if it conforms to some set of rules; if it does, a logical representation of the
  input is constructed.

  \section{Languages and grammars}

  Consider a parser for arithmetic expressions. The input of the parser is any sequence of
  characters. Invalid strings like \verb$1+$ and \verb$3//4$ get rejected. Valid strings like
  \verb$2*(3+4)$ get accepted.

  The \emph{language} accepted by a parser is the set of all possible inputs which the parser may
  accept. The set of rules to which the input has to conform to is called the \emph{grammar} of the
  language.

  As an example, we could define the grammar for arithmetic expressions as follows:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item Any sequence of characters representing a number is a \emph{literal expression};

    \item \mbox{\texttt{($x$)}} is a \emph{parenthesized expression} if $x$ is an expression;

    \item \mbox{\texttt{+$x$}} and \mbox{\texttt{-$x$}} are \emph{unary expressions} if $x$ is a
    literal or parenthesized expression;

    \item \mbox{\texttt{$x$*$y$}} and \mbox{\texttt{$x$/$y$}} are \emph{multiplicative expressions}
    if $y$ is a unary or parenthesized expression and $x$ is a unary or parenthesized or
    multiplicative expression;

    \item \mbox{\texttt{$x$+$y$}} and \mbox{\texttt{$x$-$y$}} are \emph{additive expressions}
    if $y$ is a multiplicative or parenthesized expression and $x$ is a multiplicative or
    parenthesized or additive expression;

    \item An \emph{expression} is any of the previous items.
  \end{itemize}

  According to such rules, the string \verb$2*(3+4)$ is a valid arithmetic expression. By
  definition:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \verb$2$, \verb$3$ and \verb$4$ are literals;
    \item \verb$3+4$ is an additive expression;
    \item \verb$(3+4)$ is a parenthesized expression;
    \item \verb$2*(3+4)$ is a multiplicative expression.
  \end{itemize}

  \section{Syntax trees}

  A \emph{syntax tree} is the representation of a string accepted by the parser; this data
  structure stores the syntactic structure of the input.

  A syntax tree may retain all information necessary to reconstruct the input, in which case it is
  called a \emph{concrete} syntax tree. Such a tree can be further processed by either adding or
  discarding some information; nodes within the tree can be rearranged. When there's not a
  one-to-one correspondence between the input and the produced tree, the syntax tree is said to be
  \emph{abstract}.

  Consider the language of arithmetic expressions: we can think of at least two possible syntax
  trees for the string \verb$2+3*(4+5)$, depending on how much information we want to keep. When
  information is thrown away, the semantic meaning stays the same: for instance, details about
  parenthesization can be discarded if the resulting syntax tree still represents the same order of
  operations.

  \begin{figure}[H]
    \centering

    \begin{ttfamily}
      \begin{forest}[+ [2] [* [3] [+ [4] [5]]]]\end{forest}
      \begin{forest}[+ [2] [* [3] [( ) [+ [4] [5]]]]]\end{forest}
    \end{ttfamily}

    \caption{Two semantically equivalent syntax trees for \mbox{\texttt{2+3*(4+5)}}}
  \end{figure}

  As we'll see later, the parser for Devin uses a single tree representation which retains enough
  information for syntax highlighting, but also discards whitespace and comments. For our purposes,
  the distinction between abstract and concrete syntax tree isn't necessary: for this reason, from
  now on I'll just use the term \emph{syntax tree}.

  \section{Parser combinators}

  There are many ways to recognize some input and generate an associated syntax tree. There has been
  much academic research, and it is trivial to find so-called \emph{parser generators}: these are
  tools which, given a grammar, automatically generate code for parsing the language in question.
  These tools build upon well-known algorithms, such as LL, LR, LALR, just to throw a few names
  around. These tools are great and very performant; however, they're kind of magical.

  In this section, we'll see how there's no fundamental need for any generators; although such tools
  are handy, it isn't actually that difficult to write a parser from scratch, using a technique
  called \emph{recursive descent parsing}. Recursive descent parsers are used by the GCC compiler
  and the V8 JavaScript engines, for example\cite{nystrom}.

  Recursive descent is a method of constructing a parser using a collection of recursive functions.
  The simplest functions parse the atoms (or \emph{tokens}) of the target language; examples of such
  functions are parsers for numbers and identifiers. By gluing together simpler functions, more
  complex parsers can be created: for example, a parser for two-dimensional coordinates
  \mbox{\texttt{($x$,$y$)}} can be built by using the parsers for open-parenthesis, number, comma,
  number, and close-parenthesis respectively. Finally, parsers can be combined recursively: a parser
  $P$ could depend on a parser $Q$, which in turn depends on $P$. Consider any language supporting
  while statements: the body of the loop is yet another statement, which in turn could be a while
  statement.

  Recursive descent can be implemented in any imperative language; of course, a similar technique
  can be applied in functional programming as well. The functional approach lends itself perfectly
  for this kind of task; in particular, higher order functions abstract the boilerplate necessary to
  glue together different parsing functions. These higher order functions are called \emph{parser
  combinators}, as they combine simpler parsers into more complex ones.

  The general interface employed by parser combinators is that of a function which takes some input
  string and returns either an error or some result together with the remaining input. For instance,
  applying the function parsing an integer on the input string \verb$21*2$ yields the pair
  \mbox{$\left(21, \texttt{*2}\right)$}.

  While it would be somewhat trivial to implement simple parser combinators from scratch, there is a
  huge amount of libraries which provide such functionality for free. Some common parser combinators
  are:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item The \emph{sequence combinator}. Informally, this combinator runs two parsers in succession
    and combines their results.

    Let $P$ and $Q$ be two parsers. The sequence combinator runs $P$; if it succeeds, then $Q$ is
    run on the remaining input. If $Q$ also succeeds, the combinator succeeds with the combined
    results of $P$ and $Q$. If $P$ or $Q$ fail, then the combinator also fails.

    \item The \emph{alternative combinator}. This combinator implements choice.

    Let $P$ and $Q$ be two parsers. The alternative combinator runs $P$ and $Q$ on the same input.
    If $P$ succeeds, the combinator succeeds with the same result as $P$ did; if $Q$ succeeds, the
    combinator succeeds with the same result as $Q$ did. If both $P$ and $Q$ fail, then the
    combinator also fails.

    \item The \emph{option combinator}. This combinator runs a parser zero or one time.

    Let $P$ be a parser. The option combinator tries to run $P$. If $P$ succeeds, the combinator
    succeeds with the same result as $P$ did. If $P$ fails, the combinator succeeds with an empty
    result.

    \item The \emph{repetition combinator}. This combinator runs a zero or more times.

    Let $P$ be a parser. The repetition combinator tries to run $P$ as many times as possible, until
    $P$ fails. Each time $P$ succeeds, the remaining input is fed back into the next application of
    $P$ itself. This combinator succeeds with the accumulated results of all successful runs.

    \item The \emph{bind combinator}. This combinator allows one parser to depend on the result of
    another parser. This is the most powerful combinator of them all: other combinators could be
    expressed in terms of bind.

    Let $P$ be a parser and $f$ a one-parameter function yielding another parser. The bind
    combinator tries to run $P$; if it succeeds, it applies $f$ on the result of $P$, running the
    resulting parser on the remaining input. If $P$ fails, this combinator also fails.
  \end{itemize}

  \chapter{Tree traversal}

  The syntax tree constructed by the parser can be traversed in a multitude of ways. In general,
  syntax trees can not only represent the structure of a programming languages, but also the
  structure of markup languages or other kinds of languages. For the purposes of this thesis, I'll
  discuss the processing of programming languages only.

  It is important to note the grammar of a language only describes its \emph{syntax}: on its own,
  it only defines which inputs strings are valid and which are not. Similarly, a parser only
  maps syntactically valid input strings into trees: it is the role of other components to give
  \emph{semantic meaning} to such trees.

  \begin{itemize}[noitemsep,topsep=0pt]
    \item An \emph{evaluator} would associate the nodes of a syntax tree with actions to execute.
    Examples of such actions are performing arithmetic calculations, conditionally executing
    subtrees, and assigning or retrieving values from variables.

    \item A \emph{compiler} would translate a syntax tree into some other form. For instance, the
    GCC compiler produces object files from valid C syntax; in turn, object files can be parsed by
    the system's linker, which translates a collection of such files into a runnable executable.

    \item On languages where the semantics involve static types, a \emph{type checker} would verify
    that no type errors would be produced by evaluation/compilation. In such systems, the type
    checker coexists with the evaluator/compiler; it is fundamental that all components obey to the
    same semantics.

    \item A \emph{linter} would analyze the syntax tree, suggesting how to improve the original
    source code. Contrary to the type checking, linting may not depend on static types (if any);
    furthermore, successful compilation/execution doesn't depend on the linter. As it is the case
    for the type checker, all components must obey to the same semantics.

    \item A \emph{syntax highlighter} would use the information stored in a syntax tree to perform
    syntax highlighting. Such a syntax tree would be rather concrete, as each node would be
    associated with a position in the parser's input string.
  \end{itemize}

  \chapter{A first look at Devin}

  In this thesis, I'll discuss the implementation of a simple imperative programming language which
  I decided to call Devin. The name Devin is an homage to Duino, the city I'm currently living in;
  its slovenian name is, in fact, Devin.

  Alongside Devin, I developed a graphical text editor for the language. The editor features syntax
  highlighting, error reporting, and a simple visual debugger.

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{2.png}
    \caption{The graphical editor associated with Devin}
    \label{ex1}
  \end{figure}

  \section{Language features}

  Devin is an imperative programming language with lexical variable scoping and support for
  recursive function definitions. Syntactically, it is very similar to any C descendant; among
  others, it supports variable definition and assignment, while loops, do-while loops, and
  branching. Two significant differences from C are the syntax required to specify parameter types
  and the lack of for loops.

  \subsection{Data types}

  Devin supports the following data types:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \verb$Bool$, for the boolean values \verb$true$, \verb$false$;

    \item \verb$Int$, for 64-bit integers like \verb$11$, \verb$+12$, \verb$-42$;

    \item \verb$Float$, for double-precision floating-point numbers like \verb$34.12$, \verb$+11.0$,
    \verb$-2.56$;

    \item \mbox{\texttt{[$T$]}}, for arrays like \verb$[22, 23, 24]$, \verb$[true]$,
    \verb$[[2.1, 2.2], [4.2, 5.1]]$, \verb$[]$.
  \end{itemize}

  In addition to the items above, Devin has a \emph{unit type} named \verb$Unit$; it is inhabited by
  one value only: \verb$unit$. Unit types can be used in lieu of void types: when a procedure has
  side effects only, it marked as returning \verb$Unit$.

  One of the advantages of unit types is the uniform treatment of function calls, as there's no need
  to distinguish between procedures which return a value and those which return no value. While unit
  types are traditionally used in functional programming languages, some recent imperative languages
  like Rust incorporate this feature as well.

  Operands of any type can be compared via \mbox{\texttt{$x$ == $y$}} and
  \mbox{\texttt{$x$ != $y$}}.

  \subsection{Operations on booleans}

  Let $p$ and $q$ denote booleans. The following operations are supported:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \emph{Boolean negation}: \mbox{\texttt{not $p$}};
    \item \emph{Conjunction}: \mbox{\texttt{$p$ and $q$}};
    \item \emph{Disjunction}: \mbox{\texttt{$p$ or $q$}};
    \item \emph{Exclusive disjunction}: \mbox{\texttt{$p$ xor $q$}}.
  \end{itemize}

  Conjunction and disjunction have the same semantic as in C: if the left operand already determines
  the truthfulness of the whole expression, then the right operand isn't evaluated.

  \subsection{Operations on numbers}

  Integers and floating-point numbers support the following set of operations:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \emph{Negation}: \mbox{\texttt{-$x$}};

    \item \emph{Identity}: \mbox{\texttt{+$x$}};

    \item \emph{Addition}: \mbox{\texttt{$x$ + $y$}};

    \item \emph{Subtraction}: \mbox{\texttt{$x$ - $y$}};

    \item \emph{Multiplication}: \mbox{\texttt{$x$ * $y$}};

    \item \emph{Division}: \mbox{\texttt{$x$ / $y$}}. If $x$ and $y$ are integers, its value is
    \mbox{$\left\lfloor\frac{x}{y}\right\rfloor$};

    \item \emph{Modulo}: \mbox{\texttt{$n$ \% $m$}}. Both $n$ and $m$ need to be integers; the
    result is \mbox{$n - m \left\lfloor\frac{n}{m}\right\rfloor$};

    \item \emph{Comparison}: \mbox{\texttt{$x$ < $y$}}, \mbox{\texttt{$x$ <= $y$}},
    \mbox{\texttt{$x$ > $y$}}, \mbox{\texttt{$x$ >= $y$}}. Yields a boolean.
  \end{itemize}

  Binary operations require both operands to be of the same type: there are no implicit type
  conversions like in C, as Devin is a \emph{strongly typed} programming language. The rationale
  behind Devin's design decisions is discussed later.

  \subsection{Operations on arrays}

  Arrays support the following operations:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \emph{Element access}: \mbox{\texttt{$a$[$i$]}}, where $a$ denotes an array and $i$
    denotes an integer index. The expression retrieves the $i$-th element of the array. Like in most
    programming languages, the first element of the array has index $0$.

    \item \emph{Length information}: \mbox{\texttt{len $a$}}. The expression returns the number of
    elements contained in the array $a$.

    \item \emph{Concatenation}: \mbox{\texttt{$a$ + $b$}}. The expression yields a new array
    containing the elements of $a$ concatenated with the elements of $b$;

    \item \emph{Repetition}: \mbox{\texttt{$n$ * $a$}} or \mbox{\texttt{$a$ * $n$}}. Equivalent to
    concatenating $a$ to itself $n$ times.
  \end{itemize}

  \subsection{Assignment}

  Variables and array elements can be assigned to with the \verb$=$ operator. Devin supports the
  following shorthands:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \mbox{\texttt{$x$ += $y$}}, which is the same as \mbox{\texttt{$x$ = $x$ + $y$}};
    \item \mbox{\texttt{$x$ -= $y$}}, which is the same as \mbox{\texttt{$x$ = $x$ - $y$}};
    \item \mbox{\texttt{$x$ *= $y$}}, which is the same as \mbox{\texttt{$x$ = $x$ * $y$}};
    \item \mbox{\texttt{$x$ /= $y$}}, which is the same as \mbox{\texttt{$x$ = $x$ / $y$}};
    \item \mbox{\texttt{$x$ \%= $y$}}, which is the same as \mbox{\texttt{$x$ = $x$ \% $y$}}.
  \end{itemize}

  \subsection{Variable definitions and scoping}

  As most imperative programming languages, Devin supports variable definitions. They have the form
  \mbox{\texttt{var $x$ = $y$}}, where $x$ is an identifier and $y$ is an expression. Variables can
  be defined at any point, whether globally or as function locals.

  Devin is \emph{block-structured}: it allows for the creation of blocks, including blocks nested
  within other blocks. Variables are lexically scoped: they can't be accessed from outside the block
  they are defined in. Like in C, blocks consist of a sequence of statements wrapped in a pair of
  curly braces (\verb${$, \verb$}$).

  Statements are always terminated with semicolons. Empty statements are disallowed: in other words,
  a semicolon on its own is not a valid statement.

  \subsection{Looping mechanisms}

  The following two looping constructs are supported:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \emph{While loops} in the form \mbox{\texttt{while $p$ $s$}}. This construct runs the
    statement $s$ as long as the expression $p$ is true;

    \item \emph{Do-while loops} in the form \mbox{\texttt{do $s$ while $p$}}. This construct runs
    $s$ once; then, it re-runs $s$ as long as $p$ is true.
  \end{itemize}

  \subsection{Assertions}

  Devin provides a mechanism for asserting that predicates evaluate to \verb$true$ at runtime.
  Assertions can be used to check internal assumptions or to guard against violation of function
  contracts, among other things.

  For example, the assertion  \mbox{\texttt{assert $n$ >= 0}} can be used as the first statement of
  a function calculating the factorial of $n$, as the result not defined if \mbox{$n < 0$}.

  \subsection{Procedure definition and application}

  Procedures can be defined either globally or within other procedures. Procedures obey to the same
  scoping rules as variables. The entry point for Devin programs is a global procedure named
  \verb$main$; it must take no arguments.

  By default, procedure arguments are passed by value; with the \texttt{ref} keyword, they can be
  passed by reference instead.

  The syntax for calling procedures is the same as in C: \mbox{\texttt{$f$()}} calls $f$ with zero
  arguments, \mbox{\texttt{$g$($x$)}} calls $g$ with a single argument,
  \mbox{\texttt{$h$($x$, $y$)}} calls $h$ with two arguments. The evaluation strategy of Devin is
  strict; arguments are evaluated from left to right.

  \begin{figure}[H]
    \center

\begin{verbatim}
def sum1(a: Int, b: Int) -> Int
    return a + b;

def sum2(a: Int, b: Int, ref into: Int) -> Unit
    into = a + b;
\end{verbatim}

    \caption{Two different ways of writing a procedure summing up two numbers}
  \end{figure}

  \subsection{Optional types}

  A peculiar feature of Devin is that of \emph{optional types}. With optional types, the semantic of
  the language doesn't depend on a static type system\cite{bracha}. A notable example of an
  optionally typed language is Python.

  Type annotations may be omitted from Devin programs. Type checking is not performed on terms where
  type annotations are missing. Effectively, this makes Devin statically typed only if \emph{all}
  terms are annotated; if \emph{no} type annotations are provided, Devin becomes dynamically typed.

  \begin{figure}[H]
    \center

\begin{verbatim}
def sum1(a, b: Int)
    return a + b;

def sum2(a, b, ref into) -> Unit
    into = a + b;
\end{verbatim}

    \caption{Two procedures written without some type annotations}
  \end{figure}

  \section{Editor features}

  Devin is bundled with a code editing UI built upon GTK+, a popular library for creating graphical
  user interfaces. GTK+ works on Windows, macOS, and many UNIX-like platforms\cite{gtk+}. The code
  editor is supported by GtkSourceView, a library that extends the GTK+ framework for text editing
  and support for configurable syntax highlighting\cite{gtksourceview}.

  GtkSourceView is powerful enough to automatically perform syntax highlighting if an appropriate
  language definition is provided. Devin doesn't use this feature: if the library's automatic
  syntax highlighting was to be used, much care would have to be taken in order to keep
  GtkSourceView's language definition and Devin's manually written parser in sync.

  Other than syntax highlighting, Devin's editor features error reporting: both syntactic and
  semantic errors are displayed according to their position within the source code.

  \begin{figure}[H]
    \center
    \includegraphics[width=0.9\linewidth]{4.png}
    \caption{Semantic error reporting and highlighting}
  \end{figure}

  Once a valid program has been written, it can be run by clicking the {\faPlay} button. The state
  of execution can be observed with debug statements; these signal the evaluator to pause execution
  and display the values currently stored in the \emph{run-time stack}---the data structure which
  maps values to variables and function arguments. Each time a function gets called, a new
  \emph{stack frame} is pushed onto the stack; the new frame contains associations between argument
  names and values. Variable definitions within the called function will add new associations to the
  newly pushed frame. When the called function returns, the topmost frame is popped off the stack
  and execution continues normally.

  Devin has been designed with simplicity of implementation in mind. In particular, Devin's call
  stack exhibits two uncommon properties:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item Each block pushes a new frame onto the stack: this allows treating nested scopes with the
    same mechanism as function calls. The debugger skips visualization of empty blocks, as they
    occur somewhat frequently.

    \item Execution always starts with a non-empty stack containing a single frame. This frame binds
    the names \verb$true$ to the truth value, \verb$false$ to \verb$not true$, and \verb$unit$ to
    the unit value. In practice, this means that \verb$true$, \verb$false$ and \verb$unit$ are not
    special keywords or constants; instead, they are ordinary variables. This is a deliberate design
    decision.
  \end{itemize}

  \begin{figure}[H]
    \center
    \includegraphics[width=0.9\linewidth]{5.png}
    \caption{The debugger displaying the current state of the stack}
  \end{figure}

  Runtime errors are handled as well. When an error occurs, the offending code fragment is
  highlighted and a message dialog describing the problem is shown to the user. Runtime errors
  include, but are not limited to, index out of bounds errors, division by zero, assertion errors.

  \begin{figure}[H]
    \center
    \includegraphics[width=0.9\linewidth]{6.png}
    \caption{Runtime error reporting and highlighting}
  \end{figure}

  \chapter{Devin's design choices}

  \section{Operations between numeric types}

  \section{Independence between evaluator and type checker}

  \section{Optional types}

  \chapter{Implementing Devin}

  Devin's implementation spans approximately 4500 lines of code. Knowledge about programming in
  Haskell or any ML derived language is required for understanding this chapter. It will be assumed
  that the reader is at least somewhat familiar with functional programming, in particular with the
  concepts of pure functions and higher order functions; more advanced concepts like functors and
  monads are not required: they'll be introduced informally, as needed.

  Devin is written entirely in Haskell, a purely functional programming language. Within Haskell,
  purity boils down to the language being \emph{referentially transparent}: every expression can
  be replaced with the value would evaluate to, without changing the program's semantics. In
  practice: no functions perform side-effects.

  Haskell's approach to encoding effects---reading files, modifying environment variables, printing
  to console---is straight forward. There are no procedures executing I/O actions; instead, there
  is a collection of functions returning \emph{fragments of code} which, when run, perform the
  actual computation. For instance, there's no procedure which reads from console and returns a
  string; there's a function which evaluates to a code fragment which reads from console and yields
  a string. Haskell's signature this function is \verb$Handle -> IO String$: given a handle
  (\verb$stdin$, in our case), this function evaluates to an \verb$IO$ action computing a
  \verb$String$. Multiple \verb$IO$ actions can be easily combined together using a combination of
  syntactic sugar and functions from Haskell's base library.

  \section{The syntax tree}

  Devin's syntax tree retains all the necessary information to perform syntax highlighting. Given a
  node in the tree, it is always possible to determine its \emph{position} within the parsed source
  code. Leaf nodes store their positions directly; for non-leaf nodes, this value can be computed
  instead.

  Two essential leaf nodes are \verb$SymbolId$ and \verb$Token$. They store information about
  identifiers (e.g. \verb$list$, \verb$x$, \verb$Int$) and tokens (e.g. \verb${$, \verb$}$, \verb$->$)
  respectively. As tokens are only used for syntax highlighting, only their position is stored.
  Leaf nodes store both their starting and ending position in a tuple. As such, \verb$SymbolId$ and
  \verb$Token$ are defined as follows\footnote{As Haskellers will notice, the definition of
  \mbox{\texttt{interval}} is duplicated across two different data types. This is not allowed in
  vanilla Haskell2010; such behavior can be enabled with the \mbox{\texttt{DuplicateRecordFields}}
  extension}:

\begin{verbatim}
data SymbolId = SymbolId {name :: String, interval :: (Int, Int)}
data Token = Token {interval :: (Int, Int)}
\end{verbatim}

  \subsection{Representing expressions}

  Devin supports 4 unary operators: \verb$+$, \verb$-$, \verb$not$, \verb$len$. Unary operators are
  represented by the algebraic data type \verb$UnaryOperator$, defined as follows:

\begin{verbatim}
data UnaryOperator
  = PlusOperator {interval :: (Int, Int)}
  | MinusOperator {interval :: (Int, Int)}
  | NotOperator {interval :: (Int, Int)}
  | LenOperator {interval :: (Int, Int)}
\end{verbatim}

  Devin has 20 binary operators: \verb$+$, \verb$-$, \verb$*$, \verb$/$, \verb$%$, \verb$==$,
  \verb$!=$, \verb$<$, \verb$<=$, \verb$>$, \verb$>=$, \verb$and$, \verb$or$, \verb$xor$, \verb$=$,
  \verb$+=$, \verb$-=$, \verb$*=$, \verb$/=$, \verb$%=$. Binary operators are represented by the
  type \verb$BinaryOperator$:

\begin{verbatim}
data BinaryOperator
  = AddOperator {interval :: (Int, Int)}
  | SubtractOperator {interval :: (Int, Int)}
  | MultiplyOperator {interval :: (Int, Int)}
  | DivideOperator {interval :: (Int, Int)}
  | ModuloOperator {interval :: (Int, Int)}
  | EqualOperator {interval :: (Int, Int)}
  | NotEqualOperator {interval :: (Int, Int)}
  | LessOperator {interval :: (Int, Int)}
  | LessOrEqualOperator {interval :: (Int, Int)}
  | GreaterOperator {interval :: (Int, Int)}
  | GreaterOrEqualOperator {interval :: (Int, Int)}
  | AndOperator {interval :: (Int, Int)}
  | OrOperator {interval :: (Int, Int)}
  | XorOperator {interval :: (Int, Int)}
  | PlainAssignOperator {interval :: (Int, Int)}
  | AddAssignOperator {interval :: (Int, Int)}
  | SubtractAssignOperator {interval :: (Int, Int)}
  | MultiplyAssignOperator {interval :: (Int, Int)}
  | DivideAssignOperator {interval :: (Int, Int)}
  | ModuloAssignOperator {interval :: (Int, Int)}
\end{verbatim}

  Expressions are where things get interesting. There are literals for numeric expressions and
  variables: these are leaf expressions. More complex expressions can be built from simpler ones:
  for example, a binary expression is constructed by two other expressions and a binary operator.

  Expressions are described by a single algebraic data type: \verb$Expression$. The following items
  qualify as expressions:

  \begin{itemize}[noitemsep,topsep=0pt]
    \item \emph{Variables}, e.g. \verb$list$, \verb$x$;
    \item \emph{Integer literals}, e.g. \verb$42$;
    \item \emph{Rational literals}, e.g. \verb$3.14$;
    \item \emph{Array literals}, e.g. \verb$[22, 23, 24]$;
    \item \emph{Array accesses}, e.g. \verb$x[2]$, \verb$f(y)[3]$;
    \item \emph{Function calls}, e.g. \verb$f(x)$, \verb$g(x, y)$;
    \item \emph{Unary expressions}, e.g. \verb$not x$;
    \item \emph{Binary expressions}, e.g. \verb$x + 2$;
    \item \emph{Parenthesized expressions}, e.g. \verb$(x - 3)$.
  \end{itemize}

  Opening and closing parentheses are stored in the syntax tree. Parentheses include round, square
  and curly braces. As a convention, parentheses are always identified by the \verb$open$ and
  \verb$close$ fields, regardless of the specific kind.

\begin{verbatim}
data Expression where
  VariableExpression :: {
    variableName :: String,
    interval :: (Int, Int)
  } -> Expression

  IntegerExpression :: {
    integer :: Integer,
    interval :: (Int, Int)
  } -> Expression

  RationalExpression :: {
    rational :: Rational,
    interval :: (Int, Int)
  } -> Expression

  ArrayExpression :: {
    open :: Token,
    elements :: [Expression],
    commas :: [Token],
    close :: Token
  } -> Expression

  AccessExpression :: {
    array :: Expression,
    open :: Token,
    index :: Expression,
    close :: Token
  } -> Expression

  CallExpression :: {
    functionId :: SymbolId,
    open :: Token,
    arguments :: [Expression],
    commas :: [Token],
    close :: Token
  } -> Expression

  UnaryExpression :: {
    unary :: UnaryOperator,
    operand :: Expression
  } -> Expression

  BinaryExpression :: {
    left :: Expression,
    binary :: BinaryOperator,
    right :: Expression
  } -> Expression

  ParenthesizedExpression :: {
    open :: Token,
    inner :: Expression,
    close :: Token
  } -> Expression
\end{verbatim}

  \subsection{Representing statements}

\begin{verbatim}
data Statement where
  DeclarationStatement :: {
    declaration :: Declaration
  } -> Statement

  ExpressionStatement :: {
    value :: Expression,
    semicolon :: Token
  } -> Statement

  IfStatement :: {
    ifKeyword :: Token,
    predicate :: Expression,
    trueBranch :: Statement
  } -> Statement

  IfElseStatement :: {
    ifKeyword :: Token,
    predicate :: Expression,
    trueBranch :: Statement,
    elseKeyword :: Token,
    falseBranch :: Statement
  } -> Statement

  WhileStatement :: {
    whileKeyword :: Token,
    predicate :: Expression,
    body :: Statement
  } -> Statement

  DoWhileStatement :: {
    doKeyword :: Token,
    body :: Statement,
    whileKeyword :: Token,
    predicate :: Expression,
    semicolon :: Token
  } -> Statement

  ReturnStatement :: {
    returnKeyword :: Token,
    result :: Maybe Expression,
    semicolon :: Token
  } -> Statement

  AssertStatement :: {
    assertKeyword :: Token,
    predicate :: Expression,
    semicolon :: Token
  } -> Statement

  DebugStatement :: {
    debugKeyword :: Token,
    semicolon :: Token
  } -> Statement

  BlockStatement :: {
    open :: Token,
    statements :: [Statement],
    close :: Token
  } -> Statement
\end{verbatim}

  \subsection{Representing declarations}

\begin{verbatim}
data Declaration where
  VariableDeclaration :: {
    varKeyword :: Token,
    variableId :: SymbolId,
    equalSign :: Token,
    value :: Expression,
    semicolon :: Token
  } -> Declaration

  FunctionDeclaration :: {
    defKeyword :: Token,
    functionId :: SymbolId,
    open :: Token,
    parameters :: [(Maybe Token, SymbolId, Maybe (Token, TypeId))],
    commas :: [Token],
    close :: Token,
    returnInfo :: Maybe (Token, TypeId),
    body :: Statement
  } -> Declaration
\end{verbatim}

  \section{The parser}

  \subsection{Parsing expressions}

  \subsection{Parsing statements}

  \subsection{Parsing declarations}

  \section{The type checker}

  \subsection{Type checking expressions}

  \subsection{Type checking statements}

  \subsection{Type checking declarations}

  \section{The evaluator}

  \subsection{Evaluating expressions}

  \subsection{Evaluating statements}

  \subsection{Evaluating declarations}

  \section{The UI}

  \backmatter

  % \conclusions
  % TBD

  % \appendix

  % \chapter{Some technicalities}
  % TBD

  % \section{a section}
  % TBD

  \backmatter

  \printbibliography

  % \printindex  % use makeindex to generate the index
\end{document}
