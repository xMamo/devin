\documentclass[12pt, american, draft]{PhdThesis}
%,UdineBachThesis(in cfg)

\usepackage[american]{babel}
\usepackage[final]{graphicx}

\usepackage{enumitem}
\usepackage{forest}

\forestset{
  default preamble = {
    for tree = {draw, ellipse}
  }
}

\author{Matteo Morena}
\email{morena.matteo@gmail.com}
\supervisor{Marco Comini}
\title{Implementation of an interpreter with graphical interface of a simple imperative language}
\date{2020--2021}

\begin{document}
  \pagestyle{empty}

  \maketitle

  \frontmatter

  \partstyle{serifbig}
  \chaptertitlestyle{serifbig}
  \pagestyle{serif}

  \mainmatter

  \chapter{Parsing}

  The first phase of any compiler or interpreter is called \emph{parsing}. The purpose of this
  phase is to analyze an input string and determine if it conforms to some set of rules; if it
  does, a logical representation of the input is constructed.

  Consider a parser for arithmetic expressions. The input of the parser is any sequence of
  characters. Invalid inputs like \mbox{\texttt{(1 +)}} and \mbox{\texttt{(3 * * 4)}} get rejected.
  Valid sequences of characters like \mbox{\texttt{(2 * (3 + 4))}} get accepted.

  The \emph{language} accepted by a parser is the set of all possible inputs which the parser may
  accept. The set of rules which a parser has to verify is called \emph{grammar} of the language.
  Thus, the string \mbox{\texttt{(2 * (3 + 4))}} conforms to the rules of the grammar of arithmetic
  expressions; in other words, it is a member of the language of arithmetic expressions.

  \section{Syntax trees}

  A \emph{syntax tree} is the representation of a string accepted by the parser; this data
  structure stores the logical organization of the input.

  There may or may not be a bijection between syntax trees and the original source. A syntax tree
  may retain all information necessary to reconstruct the input; in this case, it is called a
  \emph{concrete} syntax tree. If some information about the source is discarded (whitespace, for
  example), it is called an \emph{abstract} syntax tree.

  Considering again the language of arithmetic expressions, these are at least two possible syntax
  trees for the string \mbox{\texttt{(2 + 3 * (4 + 5))}}, depending on how much information has to
  be kept. If information is thrown away, the semantic meaning has to stay the same: for instance,
  details about parenthesization can be discarded if the resulting syntax tree still represents the
  same order of operations.

  \begin{figure}[h]
    \centering

    \begin{ttfamily}
      \begin{forest}[+ [2] [* [3] [+ [4] [5]]]]\end{forest}
      \begin{forest}[( ) [+ [2] [* [3] [( ) [+ [4] [5]]]]]]\end{forest}
    \end{ttfamily}

    \caption{Two semantically equivalent syntax trees for \mbox{\texttt{(2 + 3 * (4 + 5))}}}
  \end{figure}

  Notice how both syntax trees denote the fact that multiplication comes before addition. It is
  important to understand that syntax trees not only represent the orginial source, but its
  structure too.

  From now on, I will stop distinguishing between abstract and concrete syntax trees. This notion
  is surely important in theory, but the boundaries between concrete and abstract trees can become
  fuzzy in practice. Is a syntax tree which throws away spaces but keeps parentheses concrete? What
  if some additional metadata is stored in the tree: does that make it abstract? What if such a
  tree keeps all the information of the input in addition to the metadata: wouldn't it be concrete?
  The answer to these questions doesn't matter too much, as there are better questions to ask.
  Mainly, I will focus on what kind of data is stored in the tree and how can that data be used in
  each upcoming phase of the interpreter.

  \section{Recursive descent parsing}

  There are many ways to recognize some input and create an associated syntax tree. There has been
  much academic research, and it is trivial to find so-called \emph{parser generators}: these are
  tools which, given a grammar, automatically generate code for parsing the language in question.
  Such tools build upon well-known algorithms, such as LL, LR, LALR, just to throw a few names
  around. These tools are great and very performant; however, they're kind of magical.

  In this section, we'll see how there's no need for any generators; although such tools are handy,
  it isn't actually that difficult to write a parser from scratch, using a technique called
  \emph{recursive descent parsing}.

  TODO
\end{document}
